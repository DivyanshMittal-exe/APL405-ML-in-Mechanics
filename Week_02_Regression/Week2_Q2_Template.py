# -*- coding: utf-8 -*-
"""Week2_Template_MR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19c071SEqn52aV_YrSumTCsa2sY1Hnt-M

# Mulitvariate Regression Problem
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt

# %matplotlib inline

class mr:
  def __init__(self):
        self.weight = 0
        
  # Evaluates the gradient of cost function (J). Hint: You can use this to optimize w
  def grad(self,x,y,w):
    x = x.T
    rows, columns = x.shape
    # mat =np.vstack([np.ones(columns),x])
    J = (np.dot(w,x) - y)
    grad_J = np.dot(x,J.T)
    grad_J = np.divide(grad_J,columns)
    return grad_J

  # This function calculates the cost (J)
  def computeCost(self,x,y,w):
    x = x.T
    J = 0    # J is cost function
    # write your code to calculate J
    rows, columns = x.shape
    # mat =np.vstack([np.ones(columns),x])
    k = (np.dot(w,x) - y)
    k = np.square(k)
    J = np.sum(k)/(2*columns)

    return J
  
  # This function optimizes the weights w_0, w_1, w_2. Batch Gradient Descent method
  def bgdMulti(self, x, y, w, alpha, iters):
    
    m = y.size  # number of training examples
    w = w.copy() # To keep a copy of original weights
    
    J_history = []   # Use a python list to save cost in every iteration

    for i in range(iters):
      j = self.computeCost(x,y,w)
      grad_J = self.grad(x,y,w)
      w = np.subtract(w,np.multiply(alpha,grad_J))
      J_history.append(j)
      # Loop to update weights (w vector)
      # Also save cost at every step

    self.weight = w
    return w, J_history
  
  # Estimate the price of a 4 bedrooms, 2.5 bathrooms, 2570 sq. feet area, 2 floors, 2005 yr. built
  # You need to rescale all the values, mu is mean of all X data of each column, sigma is standard deviation of X data. mu , sigma will be vector
  # You need to do feature normalization of all X (see lab notes)
  

  def predict(self, mu, sigma):
    price = 0  # predict the price of the house
    ar = np.array([4,2.5,2570,2,2005])
    ar = np.divide(np.subtract(ar,mu),sigma)
    ar = np.append(1,ar)
    price = np.dot(self.weight,ar)
    error =  ((719000 - price)/719000)*100
    
    return error